// Generated by CoffeeScript 1.6.2
var AttributeExpression, AttributesExpression, BaseParser, BindingExpression, ChildrenExpression, CollectionExpression, NodeExpression, Parser, RootExpression, StringExpression, StringNodeExpression, TextBindingExpression, TextStringExpression, TokenCodes, Tokenizer, bindingParser,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseParser = require("../base/parser");

Tokenizer = require("./tokenizer");

TokenCodes = Tokenizer.Codes;

bindingParser = require("../binding/parser");

RootExpression = require("./expressions/root");

NodeExpression = require("./expressions/node");

StringExpression = require("./expressions/string");

BindingExpression = require("./expressions/binding");

ChildrenExpression = require("./expressions/children");

AttributeExpression = require("./expressions/attribute");

AttributesExpression = require("./expressions/attributes");

CollectionExpression = require("./expressions/collection");

TextStringExpression = require("./expressions/textString");

TextBindingExpression = require("./expressions/textBinding");

StringNodeExpression = require("./expressions/stringNode");

Parser = (function(_super) {
  __extends(Parser, _super);

  /*
  */


  function Parser() {
    Parser.__super__.constructor.call(this);
    this._t = new Tokenizer();
  }

  /*
  */


  Parser.prototype._parse = function() {
    var expr, expressions, i;

    expressions = [];
    i = 0;
    this._nextCode();
    while (this._t.current) {
      expr = this._parseExpression();
      if (expr) {
        expressions.push(expr);
      }
    }
    return new RootExpression(new CollectionExpression(expressions));
  };

  /*
  */


  Parser.prototype._parseExpression = function() {
    var ccode;

    if (!(ccode = this._currentCode())) {
      return null;
    }
    if (ccode === TokenCodes.LT) {
      return this._parseNode();
    } else if (ccode === TokenCodes.SBLOCK) {
      return this._parseBindingBlock();
    } else if (ccode === TokenCodes.SN) {
      return this._parseStringNode();
    } else {
      return this._parseText();
    }
  };

  /*
  */


  Parser.prototype._parseStringNode = function() {
    var cs;

    cs = this._currentString();
    this._nextCode();
    return new StringNodeExpression(cs);
  };

  /*
  */


  Parser.prototype._parseNode = function() {
    var attributes, cchar, children, name;

    name = this._nextString();
    this._nextCode();
    attributes = this._parseAttributes();
    while ((cchar = this._currentCode()) && cchar) {
      if (cchar === TokenCodes.GT) {
        this._nextCode();
        children = this._parseChildren(name);
        break;
      } else if (cchar === TokenCodes.ETNC) {
        this._nextCode();
        break;
      } else {
        this._nextCode();
      }
    }
    return new NodeExpression(name, attributes, children);
  };

  /*
  */


  Parser.prototype._parseAttributes = function() {
    var attrs, ccode;

    attrs = [];
    while (ccode = this._currentCode()) {
      if ((TokenCodes.GT | TokenCodes.ETNC) & ccode) {
        break;
      }
      if (ccode === TokenCodes.WS) {
        this._nextCode();
        continue;
      }
      attrs.push(this._parseAttribute());
    }
    if (!attrs.length) {
      return null;
    }
    return new AttributesExpression(attrs);
  };

  /*
  */


  Parser.prototype._parseChildren = function(nodeName) {
    var ccode, children, ended;

    children = [];
    ended = false;
    while ((ccode = this._currentCode()) && ccode) {
      if ((TokenCodes.GT | TokenCodes.EBLOCK) & ccode) {
        break;
      }
      if (ccode === TokenCodes.ETAG) {
        ended = true;
        this._nextCode();
        break;
      }
      children.push(this._parseExpression());
    }
    if (!ended) {
      throw new Error("tag <" + nodeName + "> has no ending tag </" + nodeName + ">");
    }
    if (!children.length) {
      return null;
    }
    return new CollectionExpression(children);
  };

  /*
  */


  Parser.prototype._parseAttribute = function() {
    var name, value;

    name = this._currentString();
    if (this._nextCode() === TokenCodes.EQ) {
      this._nextCodeSkipWs();
      value = this._parseAttributeValue();
    }
    return new AttributeExpression(name, value);
  };

  /*
  */


  Parser.prototype._parseAttributeValue = function() {
    var quoteCode, ret;

    quoteCode = this._currentCode();
    this._nextCode();
    ret = this._parseAttrTextUntil(quoteCode);
    this._nextCodeSkipWs();
    return ret;
  };

  /*
  */


  Parser.prototype._parseText = function() {
    return this._parseTextUntil(TokenCodes.EBLOCK | TokenCodes.SBLOCK | TokenCodes.LT | TokenCodes.ETAG);
  };

  /*
  */


  Parser.prototype._parseTextUntil = function(scode) {
    var ccode, items, str;

    items = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      if (ccode === TokenCodes.LM) {
        items.push(this._parseTextBinding());
      } else {
        str = this._parseTextString(TokenCodes.LM | scode);
        if (str) {
          items.push(str);
        }
      }
    }
    return new CollectionExpression(items);
  };

  /*
  */


  Parser.prototype._parseAttrTextUntil = function(scode) {
    var ccode, items, str;

    items = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      if (ccode === TokenCodes.LM) {
        items.push(this._parseScript());
      } else {
        str = this._parseString(TokenCodes.LM | scode);
        if (str) {
          items.push(str);
        }
      }
    }
    return new CollectionExpression(items);
  };

  /*
  */


  Parser.prototype._parseString = function(scode) {
    var buffer, ccode;

    buffer = [];
    while (!((ccode = this._currentCode()) & scode) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    return new StringExpression(buffer.join(""));
  };

  /*
  */


  Parser.prototype._parseTextString = function(scode) {
    return new TextStringExpression(this._parseString(scode));
  };

  /*
  */


  Parser.prototype._parseBindingBlock = function(isChild) {
    var ccode, child, children, script;

    script = this._parseScript(isChild);
    children = [];
    while ((ccode = this._currentCode()) !== TokenCodes.EBLOCK && ccode) {
      children.push(this._parseExpression());
    }
    this._nextCode();
    if (this._currentCode() !== TokenCodes.RM) {
      this._t.putBack();
      child = this._parseBindingBlock(true);
    } else {
      this._nextCode();
    }
    return new BindingExpression(script, new CollectionExpression(children), child);
  };

  /*
  */


  Parser.prototype._parseTextBinding = function() {
    return new TextBindingExpression(this._parseScript());
  };

  /*
  */


  Parser.prototype._parseScript = function(isChild) {
    var buffer, ccode, script;

    this._nextCode();
    buffer = [];
    while (((ccode = this._currentCode()) !== TokenCodes.RM) && ccode) {
      buffer.push(this._currentString());
      this._nextCode();
    }
    if (isChild) {
      buffer.unshift("/");
    }
    script = bindingParser.parse(buffer.join(""));
    this._nextCode();
    return script;
  };

  return Parser;

})(BaseParser);

module.exports = new Parser();
