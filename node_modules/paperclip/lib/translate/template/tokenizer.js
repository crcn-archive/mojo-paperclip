// Generated by CoffeeScript 1.6.2
var BaseTokenizer, Codes, Tokenizer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseTokenizer = require("../base/tokenizer");

/*
 <div id="test">

 </div>
*/


Codes = (function() {
  function Codes() {}

  Codes.OTHER = -1;

  Codes.WORD = 2;

  Codes.LT = Codes.WORD << 1;

  Codes.GT = Codes.LT << 1;

  Codes.ETNC = Codes.GT << 1;

  Codes.BS = Codes.ETNC << 1;

  Codes.EQ = Codes.BS << 1;

  Codes.STRING = Codes.EQ << 1;

  Codes.LM = Codes.STRING << 1;

  Codes.RM = Codes.LM << 1;

  Codes.SBLOCK = Codes.RM << 1;

  Codes.EBLOCK = Codes.SBLOCK << 1;

  Codes.QUOTE = Codes.EBLOCK << 1;

  Codes.SQUOTE = Codes.QUOTE << 1;

  Codes.ETAG = Codes.SQUOTE << 1;

  Codes.BLOCK = Codes.ETAG << 1;

  Codes.CHAR = Codes.BLOCK << 1;

  Codes.COMMENT = Codes.CHAR << 1;

  Codes.HASH = Codes.COMMENT << 1;

  Codes.WS = Codes.HASH << 1;

  Codes.SN = Codes.WS << 1;

  return Codes;

})();

Tokenizer = (function(_super) {
  __extends(Tokenizer, _super);

  /*
  */


  Tokenizer.Codes = Codes;

  /*
  */


  function Tokenizer() {
    Tokenizer.__super__.constructor.call(this);
    this._s.skipWhitespace(false);
  }

  /*
  */


  Tokenizer.prototype._next = function() {
    var buffer, cchar, word;

    if (this._s.isAZ()) {
      return this._t(Codes.WORD, this._s.next(/[$_\-a-zA-Z0-9]+/));
    }
    if ((cchar = this._s.cchar()) === "<") {
      if (this._s.peek(4) === "<!--") {
        this._s.skip(4);
        buffer = ["<!--"];
        while ((cchar = this._s.cchar()) && cchar) {
          if (cchar === "-") {
            if (this._s.peek(2) === "->") {
              this._s.skip(2);
              buffer.push("->");
              break;
            }
          }
          buffer.push(cchar);
          this._s.nextChar();
        }
        return this._next();
      }
      if (this._s.peek(2) === "<!") {
        buffer = [];
        while ((cchar = this._s.cchar()) && cchar) {
          buffer.push(cchar);
          if (cchar === ">") {
            break;
          }
          this._s.nextChar();
        }
        return this._t(Codes.SN, buffer.join(""));
      } else {
        if (this._s.peek(2) === "</") {
          word = this._s.next(/[a-zA-Z0-9]+/);
          this._s.skip(1);
          return this._t(Codes.ETAG, word);
        }
        return this._t(Codes.LT, "<");
      }
    } else if (cchar === "/") {
      if (this._s.peek(2) === "/>") {
        this._s.skip(1);
        return this._t(Codes.ETNC, "/>");
      }
      return this._t(Codes.BS, "/");
    } else if (cchar === ">") {
      return this._t(Codes.GT, ">");
    } else if (this._s.isWs()) {
      this._s.next(/[\s\r\n\t]+/);
      return this._t(Codes.WS, " ");
    } else if (cchar === "{") {
      if (this._s.peek(3) === "{{/") {
        this._s.skip(2);
        return this._t(Codes.EBLOCK, "{{/");
      }
      if (this._s.peek(3) === "{{#") {
        this._s.skip(2);
        return this._t(Codes.SBLOCK, "{{#");
      }
      if (this._s.peek(2) === "{{") {
        this._s.nextChar();
        return this._t(Codes.LM, "{{");
      }
    } else if (cchar === "}") {
      if (this._s.peek(2) === "}}" && this._s.peek(3) !== "}}}") {
        this._s.nextChar();
        return this._t(Codes.RM, "}}");
      }
    } else if (cchar === "=") {
      return this._t(Codes.EQ, "=");
    } else if (cchar === "\"") {
      return this._t(Codes.QUOTE, "\"");
    } else if (cchar === "\'") {
      return this._t(Codes.SQUOTE, "\'");
    } else if (cchar === "#") {
      return this._t(Codes.HASH, "#");
    }
    return this._t(Codes.CHAR, this._s.cchar());
  };

  return Tokenizer;

})(BaseTokenizer);

module.exports = Tokenizer;
